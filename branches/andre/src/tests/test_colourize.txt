colourize.py tests
==================

This file contains tests of styling Python code.  Unfortunately, the
additional markup makes it near impossible to have short (<80 characters)
output lines.

We start by initializing a Colourizer instance, as is done in
crunchyfier.py (version 0.8).

    >>> import src.plugins.colourize as colourize
    >>> styler = colourize.Colourizer()

We now style a few code samples.  First, some straight Python code.

    >>> code_sample1 = """print 'Hello world!'
    ... for i in range(3):
    ...     print i*i
    ... class test_case(object):
    ...     def __init__(self):
    ...         pass
    ... """
    >>> styled_code1 = styler.parseListing(code_sample1)
    >>> print styled_code1
    &lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    &lt;span class='py_keyword'&gt;for&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_keyword'&gt; in&lt;/span&gt;&lt;span class='py_builtins'&gt; range&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_number'&gt;3&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_op'&gt;*&lt;/span&gt;&lt;span class='py_variable'&gt;i&lt;/span&gt;
    &lt;span class='py_keyword'&gt;class&lt;/span&gt;&lt;span class='py_variable'&gt; test_case&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_builtins'&gt;object&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;def&lt;/span&gt;&lt;span class='py_special'&gt; __init__&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_variable'&gt;self&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span&gt;        &lt;/span&gt;&lt;span class='py_keyword'&gt;pass&lt;/span&gt;
    <BLANKLINE>

We know that the generated work does the required processing as we have
done some functional testing and looked at similar code displayed by
a browser.  We will use such code samples from now on, assuming them
to be correct, as we develop additional functionality.

Next, a similar code sample but with added comments.
Note that we also removed the last empty line.

    >>> code_sample2 = """#First comment
    ... print 'Hello world!'
    ... for i in range(3):
    ...     print i*i  # another comment
    ... # yet another one
    ... class test_case(object):
    ...     def __init__(self):
    ...         pass"""

[[ Note that we need to re-initialize the Colourizer as a new instance.
This was not needed for Crunchy version prior 0.8.2 as we used to call
a reset() method after each styling (which is redundant with the new
version that does not call Colourizer directly). ]]

    >>> styler = colourize.Colourizer()
    >>> styled_code2 = styler.parseListing(code_sample2)
    >>> print styled_code2
    &lt;span class='py_comment'&gt;#First comment
    &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    &lt;span class='py_keyword'&gt;for&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_keyword'&gt; in&lt;/span&gt;&lt;span class='py_builtins'&gt; range&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_number'&gt;3&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_op'&gt;*&lt;/span&gt;&lt;span class='py_variable'&gt;i&lt;/span&gt;&lt;span class='py_comment'&gt;  # another comment&lt;/span&gt;
    &lt;span class='py_comment'&gt;# yet another one
    &lt;/span&gt;&lt;span class='py_keyword'&gt;class&lt;/span&gt;&lt;span class='py_variable'&gt; test_case&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_builtins'&gt;object&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;def&lt;/span&gt;&lt;span class='py_special'&gt; __init__&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_variable'&gt;self&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span&gt;        &lt;/span&gt;&lt;span class='py_keyword'&gt;pass&lt;/span&gt;

Note how the comments result in a </span> inserted at the beginning of the
next line.  This requires special consideration when styling code with
interpreter prompts.

Next, we redo the same tests, but this time with added line numbers.
    >>> styler = colourize.Colourizer(offset=0)
    >>> styled_code1a = styler.parseListing(code_sample1)
    >>> print styled_code1a
    &lt;span class='py_linenumber'&gt;  1 &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  2 &lt;/span&gt;&lt;span class='py_keyword'&gt;for&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_keyword'&gt; in&lt;/span&gt;&lt;span class='py_builtins'&gt; range&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_number'&gt;3&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  3 &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_op'&gt;*&lt;/span&gt;&lt;span class='py_variable'&gt;i&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  4 &lt;/span&gt;&lt;span class='py_keyword'&gt;class&lt;/span&gt;&lt;span class='py_variable'&gt; test_case&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_builtins'&gt;object&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  5 &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;def&lt;/span&gt;&lt;span class='py_special'&gt; __init__&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_variable'&gt;self&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  6 &lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span class='py_keyword'&gt;pass&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  7 &lt;/span&gt;

    >>> styler = colourize.Colourizer(offset=0)
    >>> styled_code2a = styler.parseListing(code_sample2)
    >>> print styled_code2a
    &lt;span class='py_linenumber'&gt;  1 &lt;/span&gt;&lt;span class='py_comment'&gt;#First comment
    &lt;/span&gt;&lt;span class='py_linenumber'&gt;  2 &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  3 &lt;/span&gt;&lt;span class='py_keyword'&gt;for&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_keyword'&gt; in&lt;/span&gt;&lt;span class='py_builtins'&gt; range&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_number'&gt;3&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  4 &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_op'&gt;*&lt;/span&gt;&lt;span class='py_variable'&gt;i&lt;/span&gt;&lt;span class='py_comment'&gt;  # another comment&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  5 &lt;/span&gt;&lt;span class='py_comment'&gt;# yet another one
    &lt;/span&gt;&lt;span class='py_linenumber'&gt;  6 &lt;/span&gt;&lt;span class='py_keyword'&gt;class&lt;/span&gt;&lt;span class='py_variable'&gt; test_case&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_builtins'&gt;object&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  7 &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;def&lt;/span&gt;&lt;span class='py_special'&gt; __init__&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_variable'&gt;self&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  8 &lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span class='py_keyword'&gt;pass&lt;/span&gt;

Note again how the comments ending one line result in a </span> inserted at the beginning of the
next one.

A final example that starts at line 11 (offset of 10)
    >>> styler = colourize.Colourizer(offset=10)
    >>> styled_code2b = styler.parseListing(code_sample2)
    >>> print styled_code2b
    &lt;span class='py_linenumber'&gt; 11 &lt;/span&gt;&lt;span class='py_comment'&gt;#First comment
    &lt;/span&gt;&lt;span class='py_linenumber'&gt; 12 &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    &lt;span class='py_linenumber'&gt; 13 &lt;/span&gt;&lt;span class='py_keyword'&gt;for&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_keyword'&gt; in&lt;/span&gt;&lt;span class='py_builtins'&gt; range&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_number'&gt;3&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt; 14 &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_op'&gt;*&lt;/span&gt;&lt;span class='py_variable'&gt;i&lt;/span&gt;&lt;span class='py_comment'&gt;  # another comment&lt;/span&gt;
    &lt;span class='py_linenumber'&gt; 15 &lt;/span&gt;&lt;span class='py_comment'&gt;# yet another one
    &lt;/span&gt;&lt;span class='py_linenumber'&gt; 16 &lt;/span&gt;&lt;span class='py_keyword'&gt;class&lt;/span&gt;&lt;span class='py_variable'&gt; test_case&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_builtins'&gt;object&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt; 17 &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;def&lt;/span&gt;&lt;span class='py_special'&gt; __init__&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_variable'&gt;self&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt; 18 &lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span class='py_keyword'&gt;pass&lt;/span&gt;


New stuff
========

We use TDD to change colourize.py.
First, we define a new function that will be called, instead of calling an
instance of the Colourizer class directly.
UPDATE: this function also strips empty lines; so to compare with the
previous cases, we may need to add an extra line "\n" by hand.

    >>> print styled_code1 == colourize._style(code_sample1)[0] + "\n"
    True

After adding a line numbering option, we can reproduce a second example.
(note: we cannot simply use the example with blankline for comparison;
however, this does not mean that the code does not work as intended in this case,
just that we deal with empty lines differently with the style() function as
we do with the simple parseListing method)
    >>> print styled_code2a == colourize._style(code_sample2, offset=0)[0]
    True

Extracting code from an interpreter session.
===========================================

Consider the following simulated interpreter sessions (using square brackets
and commas to represent the prompt), to be embedded in an html page.

]]] print "Hello world!"

    >>> code_sample3 = """>>> print 'Hello world!'"""
    >>> python_code3, extracted3 = colourize.extract_code_from_interpreter(code_sample3)
    >>> print python_code3
    print 'Hello world!'
    >>> print extracted3
    [('&amp;gt;&amp;gt;&amp;gt; ', 1)]

]]] print "Hello world!"
Hello world!
]]] for i in range(3):
,,,     print i*i

    >>> code_sample4 = """>>> print 'Hello world!'
    ... Hello world!
    ... >>> for i in range(3):
    ... ...     print i*i"""
    >>> python_code4, extracted4 = colourize.extract_code_from_interpreter(code_sample4)
    >>> print python_code4
    print 'Hello world!'
    for i in range(3):
        print i*i
    >>> print extracted4
    [('&amp;gt;&amp;gt;&amp;gt; ', 1), ('', 'Hello world!'), ('&amp;gt;&amp;gt;&amp;gt; ', 2), ('... ', 3)]


We can style the code as before.
    >>> styled_code3 = colourize._style(python_code3)[0]
    >>> styled_code4 = colourize._style(python_code4)[0]

For future reference, we will document as tests here styling examples
with line numbers added of the previous two cases.

    >>> print colourize._style(code_sample3, offset=4)[0]
    &lt;span class='py_linenumber'&gt;  5 &lt;/span&gt;&lt;span class="py_prompt"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    >>> print colourize._style(code_sample4, offset=0)[0]
    &lt;span class='py_linenumber'&gt;  1 &lt;/span&gt;&lt;span class="py_prompt"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;    &lt;/span&gt;&lt;span class="py_output"&gt;Hello world!&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  2 &lt;/span&gt;&lt;span class="py_prompt"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class='py_keyword'&gt;for&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_keyword'&gt; in&lt;/span&gt;&lt;span class='py_builtins'&gt; range&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_number'&gt;3&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class='py_linenumber'&gt;  3 &lt;/span&gt;&lt;span class="py_prompt"&gt;... &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_op'&gt;*&lt;/span&gt;&lt;span class='py_variable'&gt;i&lt;/span&gt;

Next, we define a function to add back the prompt and output to the
styled code from a simulated interpreter session.
    >>> fully_styled3 = colourize.add_back_prompt_and_output(styled_code3, extracted3)
    >>> print fully_styled3
    &lt;span class="py_prompt"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    >>> fully_styled4 = colourize.add_back_prompt_and_output(styled_code4, extracted4)
    >>> print fully_styled4
    &lt;span class="py_prompt"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    &lt;span class="py_output"&gt;Hello world!&lt;/span&gt;
    &lt;span class="py_prompt"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class='py_keyword'&gt;for&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_keyword'&gt; in&lt;/span&gt;&lt;span class='py_builtins'&gt; range&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_number'&gt;3&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span class="py_prompt"&gt;... &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_op'&gt;*&lt;/span&gt;&lt;span class='py_variable'&gt;i&lt;/span&gt;

By inspection, we conclude that it does appear to be correct.

In previous version, we noticed that there was a bug when a comment
was inserted as the last line of an interpreter session.  We need to
see if we have to take care of this in this version.

    >>> end_comment6 = '''>>> # this is a comment'''
    >>> python_code6, extracted6 = colourize.extract_code_from_interpreter(end_comment6)
    >>> print colourize._style(python_code6)[0]
    &lt;span class='py_comment'&gt;# this is a comment&lt;/span&gt;
    >>> styled6, py6 = colourize._style(end_comment6) # letting style do its thing
    >>> print styled6
    &lt;span class="py_prompt"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class='py_comment'&gt;# this is a comment&lt;/span&gt;
    >>> print py6
    # this is a comment

This looks ok; let us try a slightly longer example.
    >>> end_comment7 = """>>> print 'Hello world!'
    ... Hello world!
    ... >>> for i in range(3):
    ... ...     print i*i
    ... >>> # another comment."""
    >>> python_code7, extracted7 = colourize.extract_code_from_interpreter(end_comment7)
    >>> print colourize._style(python_code7)[0]
    &lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;
    &lt;span class='py_keyword'&gt;for&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_keyword'&gt; in&lt;/span&gt;&lt;span class='py_builtins'&gt; range&lt;/span&gt;&lt;span class='py_op'&gt;(&lt;/span&gt;&lt;span class='py_number'&gt;3&lt;/span&gt;&lt;span class='py_op'&gt;)&lt;/span&gt;&lt;span class='py_op'&gt;:&lt;/span&gt;
    &lt;span&gt;    &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_variable'&gt; i&lt;/span&gt;&lt;span class='py_op'&gt;*&lt;/span&gt;&lt;span class='py_variable'&gt;i&lt;/span&gt;
    &lt;span class='py_comment'&gt;# another comment.&lt;/span&gt;

Again, by inspection, this looks correct.

We now proceed to implement a new feature, intended to automatically detect
if a python code sample represents a simulated interpreter session.

ASSUMPTION: we will assume, as has been the case so far, that any code will
be aligned to the left i.e. that there is no extra spaces added at the
beginning of each line (unlike the doctests examples embedded in this page).
In the future, if it proves necessary, this condition could be relaxed,
at the cost of some minor increase complexity of the code written so far.

We consider the two simplest case first.
    >>> sample1 = '''print "Hello world!"'''
    >>> sample2 = '''>>> print "Hello world!"'''
    >>> print colourize.is_interpreter_session(sample1)
    False
    >>> print colourize.is_interpreter_session(sample2)
    True

We then consider two more cases, with blank lines inserted at the beginning:
    >>> sample7 = '''\n\nprint "Hello world!"'''
    >>> sample8 = '''   \n  \n>>> print "Hello world!"'''
    >>> print colourize.is_interpreter_session(sample7)
    False
    >>> print colourize.is_interpreter_session(sample8)
    True

We use this function inside colourize.py to proceed, reusing some
examples introduced previously.  We know, from the tests done above,
that the new version still works with non-interpreter code.  We can use
some previous examples to test the interpreter version.

    >>> print colourize._style(code_sample3)[0] == fully_styled3
    True
    >>> print colourize._style(code_sample4)[0] == fully_styled4
    True

In case we find a discrepancy, we compare with the expected result.
    >>> print colourize._style(code_sample3)[0]
    &lt;span class="py_prompt"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class='py_keyword'&gt;print&lt;/span&gt;&lt;span class='py_string'&gt; 'Hello world!'&lt;/span&gt;

Using this code with sample pages, we noted that sometimes blank lines
were added either at the beginning and/or at the end of a code sample.
As this can lead to too much blank vertical spaces inserted in html pages
displayed by Crunchy, we will introduce a function which will be used to
removed such lines.

    >>> test_blank = '\n \r\n\n\r  \nline1\nline2 followed by blank line\n\nline3\n \n'
    >>> print colourize.trim_empty_lines_from_end(test_blank)
    line1
    line2 followed by blank line
    <BLANKLINE>
    line3
    >>> test_blank2 = 'line1\nline2'
    >>> print colourize.trim_empty_lines_from_end(test_blank2)
    line1
    line2

=====================
Testing the plugin
=====================

First, we define and test a function to extract the text content from
a piece of html code, converting <br/> into "\n"

    >>> et = colourize.et
    >>> sample = "<pre>a\nb<br/>c<span>d</span></pre>"
    >>> pre = et.fromstring(sample)
    >>> print colourize.extract_code(pre)
    a
    b
    cd

We also have a function to extract the value of the linenumber option if present.
    >>> print colourize.get_linenumber_offset("junk")
    None
    >>> print colourize.get_linenumber_offset("linenumber")
    0
    >>> print colourize.get_linenumber_offset("linenumber=4")
    3
    >>> print colourize.get_linenumber_offset("linenumber =    22")
    21
    >>> print colourize.get_linenumber_offset("linenumber  start =    24")
    0
    >>> print colourize.get_linenumber_offset("LineNumber = 3")
    2

Next, a function to replace an ElementTree Element "in place".
    >>> original = '<a b="c">d<e>f</e>g</a>'
    >>> new = '<aa bb="cc">dd<ee>ff</ee>gg</aa>'
    >>> elem = et.fromstring(original)
    >>> replacement = et.fromstring(new)
    >>> elem_id = id(elem)
    >>> colourize.replace_element(elem, replacement)
    >>> print elem_id == id(elem) # same object as before
    True
    >>> print et.tostring(elem) == new # but with new content
    True

Next, we introduce a series of tests of increasing complexity.
First, some unstyled code.
    >>> sample = '<pre>print "Hello World!"</pre>'
    >>> pre = et.fromstring(sample)
    >>> pre.attrib['title'] = 'py_code'
    >>> py_code, new_elem, dummy_error = colourize.style(pre)
    >>> styled = et.tostring(new_elem)
    >>> print py_code
    print "Hello World!"
    >>> print styled
    &lt;pre class="crunchy" title="py_code"&gt;
    &lt;span class="py_keyword"&gt;print&lt;/span&gt;&lt;span class="py_string"&gt; "Hello World!"&lt;/span&gt;
    &lt;/pre&gt;


Next, some simple styled code
    >>> sample = '<pre title="junk">print "Hello World!"</pre>'
    >>> pre = et.fromstring(sample)
    >>> py_code, new_elem, dummy_error = colourize.style(pre)
    >>> styled = et.tostring(new_elem)
    >>> print py_code
    print "Hello World!"
    >>> print styled
    &lt;pre class="crunchy" title="junk"&gt;
    &lt;span class="py_keyword"&gt;print&lt;/span&gt;&lt;span class="py_string"&gt; "Hello World!"&lt;/span&gt;
    &lt;/pre&gt;

In the following example, the order of the attributes is changed by
ElementTree - at least in the version used for this test.

    >>> sample = '<pre title="junk" tag="other">print <span>"Hello World!"</span></pre>'
    >>> pre = et.fromstring(sample)
    >>> py_code, new_elem, dummy_error = colourize.style(pre)
    >>> styled = et.tostring(new_elem)
    >>> print py_code
    print "Hello World!"
    >>> print styled
    &lt;pre class="crunchy" tag="other" title="junk"&gt;
    &lt;span class="py_keyword"&gt;print&lt;/span&gt;&lt;span class="py_string"&gt; "Hello World!"&lt;/span&gt;
    &lt;/pre&gt;

Finally, a test including the linenumber option
    >>> sample = '<pre title="junk linenumber=2">print "Hello World!"</pre>'
    >>> pre = et.fromstring(sample)
    >>> py_code, new_elem, dummy_error = colourize.style(pre)
    >>> styled = et.tostring(new_elem)
    >>> print py_code
    print "Hello World!"
    >>> print styled
    &lt;pre class="crunchy" title="junk linenumber=2"&gt;
    &lt;span class="py_linenumber"&gt;  2 &lt;/span&gt;&lt;span class="py_keyword"&gt;print&lt;/span&gt;&lt;span class="py_string"&gt; "Hello World!"&lt;/span&gt;
    &lt;/pre&gt;

Make sure we parse properly from html tree with a prompt included.

    >>> sample = """<html><body><pre title="py_code">&gt;&gt;&gt; print 'Hello!'</pre></body></html>"""
    >>> tree = et.fromstring(sample)
    >>> pre2 = tree.find(".//pre")
    >>> pycode, new_elem, dummy_error = colourize.style(pre2)
    >>> print pycode
    print 'Hello!'
    >>> print et.tostring(new_elem)
    &lt;pre class="crunchy" title="py_code"&gt;
    &lt;span class="py_prompt"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="py_keyword"&gt;print&lt;/span&gt;&lt;span class="py_string"&gt; 'Hello!'&lt;/span&gt;
    &lt;/pre&gt;

Testing with a <code> element that is followed by some text; this
tests the proper handling of an Element's "tail".
    >>> sample = """<html><body><p> An embedded code sample as in
    ...            <code title="py_code">print 'Hi!'
    ...            </code> with a tail.</p></body></html>"""
    >>> tree = et.fromstring(sample)
    >>> pre2 = tree.find(".//code")
    >>> pycode, new_elem, dummy_error = colourize.style(pre2)
    >>> print pycode
    print 'Hi!'
    >>> print et.tostring(new_elem)
    &lt;code class="crunchy" title="py_code"&gt;
    &lt;span class="py_keyword"&gt;print&lt;/span&gt;&lt;span class="py_string"&gt; 'Hi!'&lt;/span&gt;
    &lt;/code&gt; with a tail.
