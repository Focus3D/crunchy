colourize.py tests
==================

This file contains tests of styling Python code.  Unfortunately, the
additional markup makes it near impossible to have short (<80 characters)
output lines.

We start by initializing a Colourizer instance, as is done in
crunchyfier.py (version 0.8).

    >>> import colourize
    >>> styler = colourize.Colourizer()

We now style a few code samples.  First, some straight Python code.

    >>> code_sample1 = """print 'Hello world!'
    ... for i in range(3):
    ...     print i*i
    ... class test_case(object):
    ...     def __init__(self):
    ...         pass
    ... """
    >>> styled_code1 = styler.parseListing(code_sample1)
    >>> print styled_code1
    <span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>
    <span class='py_keyword'>class</span><span class='py_variable'> test_case</span><span class='py_op'>(</span><span class='py_builtins'>object</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>def</span><span class='py_special'> __init__</span><span class='py_op'>(</span><span class='py_variable'>self</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>        </span><span class='py_keyword'>pass</span>
    <BLANKLINE>

We know that the generated work does the required processing as we have
done some functional testing and looked at similar code displayed by
a browser.  We will use such code samples from now on, assuming them
to be correct, as we develop additional functionality.

Next, a similar code sample but with added comments.
Note that we also removed the last empty line.

    >>> code_sample2 = """#First comment
    ... print 'Hello world!'
    ... for i in range(3):
    ...     print i*i  # another comment
    ... # yet another one
    ... class test_case(object):
    ...     def __init__(self):
    ...         pass"""
    >>> styled_code2 = styler.parseListing(code_sample2)
    >>> print styled_code2
    <span class='py_comment'>#First comment
    </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span><span class='py_comment'>  # another comment</span>
    <span class='py_comment'># yet another one
    </span><span class='py_keyword'>class</span><span class='py_variable'> test_case</span><span class='py_op'>(</span><span class='py_builtins'>object</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>def</span><span class='py_special'> __init__</span><span class='py_op'>(</span><span class='py_variable'>self</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>        </span><span class='py_keyword'>pass</span>

Note how the comments result in a </span> inserted at the beginning of the
next line.  This requires special consideration when styling code with
interpreter prompts.

Next, we redo the same tests, but this time with added line numbers.
    >>> styler.outputLineNumber = True
    >>> styled_code1a = styler.parseListing(code_sample1)
    >>> print styled_code1a
    <span class='py_linenumber'>  1 </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_linenumber'>  2 </span><span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  3 </span><span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>
    <span class='py_linenumber'>  4 </span><span class='py_keyword'>class</span><span class='py_variable'> test_case</span><span class='py_op'>(</span><span class='py_builtins'>object</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  5 </span><span>    </span><span class='py_keyword'>def</span><span class='py_special'> __init__</span><span class='py_op'>(</span><span class='py_variable'>self</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  6 </span><span>        </span><span class='py_keyword'>pass</span>
    <span class='py_linenumber'>  7 </span>
    >>> # The outputLineNumber option is currently automatically reset to be false at the end of a run
    >>> styler.outputLineNumber = True
    >>> styled_code2a = styler.parseListing(code_sample2)
    >>> print styled_code2a
    <span class='py_linenumber'>  1 </span><span class='py_comment'>#First comment
    </span><span class='py_linenumber'>  2 </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_linenumber'>  3 </span><span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  4 </span><span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span><span class='py_comment'>  # another comment</span>
    <span class='py_linenumber'>  5 </span><span class='py_comment'># yet another one
    </span><span class='py_linenumber'>  6 </span><span class='py_keyword'>class</span><span class='py_variable'> test_case</span><span class='py_op'>(</span><span class='py_builtins'>object</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  7 </span><span>    </span><span class='py_keyword'>def</span><span class='py_special'> __init__</span><span class='py_op'>(</span><span class='py_variable'>self</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  8 </span><span>        </span><span class='py_keyword'>pass</span>

Note again how the comments ending one line result in a </span> inserted at the beginning of the
next one.

New stuff
========

We use TDD to change colourize.py.
First, we define a new function that will be called, instead of calling an
instance of the Colourizer class directly. This function will return both
styled code (with html markup) and raw code (just straight Python code,
with no simulated interpreter prompts, etc.).
UPDATE: this function also strips empty lines; so to compare with the
previous cases, we may need to add an extra line "\n" by hand.

    >>> print styled_code1 == colourize.style(code_sample1)[0] + "\n"
    True

After adding a line numbering option, we can reproduce a second example.
(note: we cannot simply use the example with blankline for comparison;
however, this does not mean that the code does not work as intended in this case,
just that we deal with empty lines differently with the style() function as
we do with the simple parseListing method)
    >>> print styled_code2a == colourize.style(code_sample2, line_numbering=True)[0]
    True

In principle, for the above two examples, the raw code should be identical
to the input code.

    >>> print code_sample1 == colourize.style(code_sample1)[1] + "\n"
    True
    >>> print code_sample2 == colourize.style(code_sample2, line_numbering=True)[1]
    True


Extracting code from an interpreter session.
===========================================

Consider the following simulated interpreter sessions (using square brackets
and commas to represent the prompt), to be embedded in an html page.

]]] print "Hello world!"

    >>> code_sample3 = """&gt;&gt;&gt; print 'Hello world!'"""
    >>> python_code3, extracted3 = colourize.extract_code_from_interpreter(code_sample3)
    >>> print python_code3
    print 'Hello world!'
    >>> print extracted3
    [('&gt;&gt;&gt; ', 1)]

]]] print "Hello world!"
Hello world!
]]] for i in range(3):
,,,     print i*i

    >>> code_sample4 = """&gt;&gt;&gt; print 'Hello world!'
    ... Hello world!
    ... &gt;&gt;&gt; for i in range(3):
    ... ...     print i*i"""
    >>> python_code4, extracted4 = colourize.extract_code_from_interpreter(code_sample4)
    >>> print python_code4
    print 'Hello world!'
    for i in range(3):
        print i*i
    >>> print extracted4
    [('&gt;&gt;&gt; ', 1), ('', 'Hello world!'), ('&gt;&gt;&gt; ', 2), ('... ', 3)]

We can style the code as before.
    >>> styled_code3 = colourize.style(python_code3)[0]
    >>> styled_code4 = colourize.style(python_code4)[0]

For future reference, we will document as tests here styling examples
with line numbers added of the previous two cases.

    >>> print colourize.style(code_sample3, True)[0]
    <span class='py_linenumber'>  1 </span><span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    >>> print colourize.style(code_sample4, True)[0]
    <span class='py_linenumber'>  1 </span><span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_linenumber'>    </span><span class="py_output">Hello world!</span>
    <span class='py_linenumber'>  2 </span><span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  3 </span><span class="py_prompt">... </span><span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>

Let us add a function to remove html markup.
(I will base it on http://effbot.org/zone/re-sub.htm#strip-html)
Such a function will be used in case we get a code sample, inside a <pre>,
that would contain html markup.  For example, a tutorial writer may
want to display her styled code on the web while also wanting it to
be processed by Crunchy.  So, before Crunchy can do its markup, it would
need to remove the existing one.

    >>> stripped_code3 = colourize.strip_html(styled_code3)
    >>> print stripped_code3 == python_code3
    True
    >>> stripped_code4 = colourize.strip_html(styled_code4)
    >>> print stripped_code4 == python_code4
    True

However, if we have styled code, it might use <br/> instead of '\n' to
indicate line breaks.  So, we need to make sure we make the appropriate
conversion before removing all other markup.
    >>> fake_code5 = 'a <br>b <br/>c <br />d <BR>e < BR / >f<tag>'
    >>> print colourize.convert_br(fake_code5)
    a b c d e f<tag>

Next, we define a function to add back the prompt and output to the
styled code from a simulated interpreter session.  If we then strip html
markup, we should recover the original code (assuming no markup was present).
    >>> fully_styled3 = colourize.add_back_prompt_and_output(styled_code3, extracted3)
    >>> print colourize.strip_html(fully_styled3) == code_sample3
    True
    >>> fully_styled4 = colourize.add_back_prompt_and_output(styled_code4, extracted4)
    >>> print colourize.strip_html(fully_styled4) == code_sample4
    True

However, this does not mean that the fully_styled code was giving the right
results.  We still need to test it.
    >>> print fully_styled3
    <span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    >>> print fully_styled4
    <span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class="py_output">Hello world!</span>
    <span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class="py_prompt">... </span><span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>

By inspection, we conclude that it does appear to be correct.

In previous version, we noticed that there was a bug when a comment
was inserted as the last line of an interpreter session.  We need to
see if we have to take care of this in this version.

    >>> end_comment6 = '''&gt;&gt;&gt; # this is a comment'''
    >>> python_code6, extracted6 = colourize.extract_code_from_interpreter(end_comment6)
    >>> print colourize.style(python_code6)[0]
    <span class='py_comment'># this is a comment</span>

This looks ok; let us try a slightly longer example.
    >>> end_comment7 = """&gt;&gt;&gt; print 'Hello world!'
    ... Hello world!
    ... &gt;&gt;&gt; for i in range(3):
    ... ...     print i*i
    ... &gt;&gt;&gt; # another comment."""
    >>> python_code7, extracted7 = colourize.extract_code_from_interpreter(end_comment7)
    >>> print colourize.style(python_code7)[0]
    <span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>
    <span class='py_comment'># another comment.</span>

Again, by inspection, this looks correct.

We now proceed to implement a new feature, intended to automatically detect
if a python code sample represents a simulated interpreter session.

ASSUMPTION: we will assume, as has been the case so far, that any code will
be aligned to the left i.e. that there is no extra spaces added at the
beginning of each line (unlike the doctests examples embedded in this page).
In the future, if it proves necessary, this condition could be relaxed,
at the cost of some minor increase complexity of the code written so far.

We consider the two simplest case first.
    >>> sample1 = '''print "Hello world!"'''
    >>> sample2 = '''&gt;&gt;&gt; print "Hello world!"'''
    >>> print colourize.is_interpreter_session(sample1)
    False
    >>> print colourize.is_interpreter_session(sample2)
    True

We then consider two more cases, with blank lines inserted at the beginning:
    >>> sample3 = '''\n\nprint "Hello world!"'''
    >>> sample4 = '''   \n  \n&gt;&gt;&gt; print "Hello world!"'''
    >>> print colourize.is_interpreter_session(sample3)
    False
    >>> print colourize.is_interpreter_session(sample4)
    True

We use this function inside colourize.py to proceed, reusing some
examples introduced previously.  We know, from the tests done above,
that the new version still works with non-interpreter code.  We can use
some previous examples to test the interpreter version.

    >>> print colourize.style(code_sample3)[0] == fully_styled3
    True
    >>> print colourize.style(code_sample4)[0] == fully_styled4
    True

Using this code with sample pages, we noted that sometimes blank lines
were added either at the beginning and/or at the end of a code sample.
As this can lead to too much blank vertical spaces inserted in html pages
displayed by Crunchy, we will introduce a function which will be used to
removed such lines.

    >>> test_blank = '\n \r\n\n\r  \nline1\nline2 followed by blank line\n\nline3\n \n'
    >>> print colourize.trim_empty_lines_from_end(test_blank)
    line1
    line2 followed by blank line
    <BLANKLINE>
    line3
    >>> test_blank2 = 'line1\nline2'
    >>> print colourize.trim_empty_lines_from_end(test_blank2)
    line1
    line2


