colourize.py tests
==================

This file contains tests of styling Python code.  Unfortunately, the
additional markup makes it near impossible to have short (<80 characters)
output lines.

We start by initializing a Colourizer instance, as is done in
crunchyfier.py (version 0.8).

    >>> import colourize
    >>> styler = colourize.Colourizer()

We now style a few code samples.  First, some straight Python code.

    >>> code_sample1 = """print 'Hello world!'
    ... for i in range(3):
    ...     print i*i
    ... class test_case(object):
    ...     def __init__(self):
    ...         pass
    ... """
    >>> styled_code1 = styler.parseListing(code_sample1)
    >>> print styled_code1
    <span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>
    <span class='py_keyword'>class</span><span class='py_variable'> test_case</span><span class='py_op'>(</span><span class='py_builtins'>object</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>def</span><span class='py_special'> __init__</span><span class='py_op'>(</span><span class='py_variable'>self</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>        </span><span class='py_keyword'>pass</span>
    <BLANKLINE>

We know that the generated work does the required processing as we have
done some functional testing and looked at similar code displayed by
a browser.  We will use such code samples from now on, assuming them
to be correct, as we develop additional functionality.

Next, a similar code sample but with added comments.
Note that we also removed the last empty line.

    >>> code_sample2 = """#First comment
    ... print 'Hello world!'
    ... for i in range(3):
    ...     print i*i  # another comment
    ... # yet another one
    ... class test_case(object):
    ...     def __init__(self):
    ...         pass"""

[[ Note that we need to re-initialize the Colourizer as a new instance.
This was not needed for Crunchy version prior 0.8.2 as we used to call
a reset() method after each styling (which is redundant with the new
version that does not call Colourizer directly). ]]

    >>> styler = colourize.Colourizer()
    >>> styled_code2 = styler.parseListing(code_sample2)
    >>> print styled_code2
    <span class='py_comment'>#First comment
    </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span><span class='py_comment'>  # another comment</span>
    <span class='py_comment'># yet another one
    </span><span class='py_keyword'>class</span><span class='py_variable'> test_case</span><span class='py_op'>(</span><span class='py_builtins'>object</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>def</span><span class='py_special'> __init__</span><span class='py_op'>(</span><span class='py_variable'>self</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>        </span><span class='py_keyword'>pass</span>

Note how the comments result in a </span> inserted at the beginning of the
next line.  This requires special consideration when styling code with
interpreter prompts.

Next, we redo the same tests, but this time with added line numbers.
    >>> styler = colourize.Colourizer(offset=0)
    >>> styled_code1a = styler.parseListing(code_sample1)
    >>> print styled_code1a
    <span class='py_linenumber'>  1 </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_linenumber'>  2 </span><span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  3 </span><span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>
    <span class='py_linenumber'>  4 </span><span class='py_keyword'>class</span><span class='py_variable'> test_case</span><span class='py_op'>(</span><span class='py_builtins'>object</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  5 </span><span>    </span><span class='py_keyword'>def</span><span class='py_special'> __init__</span><span class='py_op'>(</span><span class='py_variable'>self</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  6 </span><span>        </span><span class='py_keyword'>pass</span>
    <span class='py_linenumber'>  7 </span>

    >>> styler = colourize.Colourizer(offset=0)
    >>> styled_code2a = styler.parseListing(code_sample2)
    >>> print styled_code2a
    <span class='py_linenumber'>  1 </span><span class='py_comment'>#First comment
    </span><span class='py_linenumber'>  2 </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_linenumber'>  3 </span><span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  4 </span><span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span><span class='py_comment'>  # another comment</span>
    <span class='py_linenumber'>  5 </span><span class='py_comment'># yet another one
    </span><span class='py_linenumber'>  6 </span><span class='py_keyword'>class</span><span class='py_variable'> test_case</span><span class='py_op'>(</span><span class='py_builtins'>object</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  7 </span><span>    </span><span class='py_keyword'>def</span><span class='py_special'> __init__</span><span class='py_op'>(</span><span class='py_variable'>self</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  8 </span><span>        </span><span class='py_keyword'>pass</span>

Note again how the comments ending one line result in a </span> inserted at the beginning of the
next one.

A final example that starts at line 11 (offset of 10)
    >>> styler = colourize.Colourizer(offset=10)
    >>> styled_code2b = styler.parseListing(code_sample2)
    >>> print styled_code2b
    <span class='py_linenumber'> 11 </span><span class='py_comment'>#First comment
    </span><span class='py_linenumber'> 12 </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_linenumber'> 13 </span><span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'> 14 </span><span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span><span class='py_comment'>  # another comment</span>
    <span class='py_linenumber'> 15 </span><span class='py_comment'># yet another one
    </span><span class='py_linenumber'> 16 </span><span class='py_keyword'>class</span><span class='py_variable'> test_case</span><span class='py_op'>(</span><span class='py_builtins'>object</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'> 17 </span><span>    </span><span class='py_keyword'>def</span><span class='py_special'> __init__</span><span class='py_op'>(</span><span class='py_variable'>self</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'> 18 </span><span>        </span><span class='py_keyword'>pass</span>


New stuff
========

We use TDD to change colourize.py.
First, we define a new function that will be called, instead of calling an
instance of the Colourizer class directly.
UPDATE: this function also strips empty lines; so to compare with the
previous cases, we may need to add an extra line "\n" by hand.

    >>> print styled_code1 == colourize.style(code_sample1) + "\n"
    True

After adding a line numbering option, we can reproduce a second example.
(note: we cannot simply use the example with blankline for comparison;
however, this does not mean that the code does not work as intended in this case,
just that we deal with empty lines differently with the style() function as
we do with the simple parseListing method)
    >>> print styled_code2a == colourize.style(code_sample2, offset=0)
    True



Extracting code from an interpreter session.
===========================================

Consider the following simulated interpreter sessions (using square brackets
and commas to represent the prompt), to be embedded in an html page.

]]] print "Hello world!"

    >>> code_sample3 = """&gt;&gt;&gt; print 'Hello world!'"""
    >>> python_code3, extracted3 = colourize.extract_code_from_interpreter(code_sample3)
    >>> print python_code3
    print 'Hello world!'
    >>> print extracted3
    [('&gt;&gt;&gt; ', 1)]

]]] print "Hello world!"
Hello world!
]]] for i in range(3):
,,,     print i*i

    >>> code_sample4 = """&gt;&gt;&gt; print 'Hello world!'
    ... Hello world!
    ... &gt;&gt;&gt; for i in range(3):
    ... ...     print i*i"""
    >>> python_code4, extracted4 = colourize.extract_code_from_interpreter(code_sample4)
    >>> print python_code4
    print 'Hello world!'
    for i in range(3):
        print i*i
    >>> print extracted4
    [('&gt;&gt;&gt; ', 1), ('', 'Hello world!'), ('&gt;&gt;&gt; ', 2), ('... ', 3)]

We can style the code as before.
    >>> styled_code3 = colourize.style(python_code3)
    >>> styled_code4 = colourize.style(python_code4)

For future reference, we will document as tests here styling examples
with line numbers added of the previous two cases.

    >>> print colourize.style(code_sample3, offset=4)
    <span class='py_linenumber'>  5 </span><span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    >>> print colourize.style(code_sample4, offset=0)
    <span class='py_linenumber'>  1 </span><span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_linenumber'>    </span><span class="py_output">Hello world!</span>
    <span class='py_linenumber'>  2 </span><span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class='py_linenumber'>  3 </span><span class="py_prompt">... </span><span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>

Next, we define a function to add back the prompt and output to the
styled code from a simulated interpreter session.
    >>> fully_styled3 = colourize.add_back_prompt_and_output(styled_code3, extracted3)
    >>> print fully_styled3
    <span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    >>> fully_styled4 = colourize.add_back_prompt_and_output(styled_code4, extracted4)
    >>> print fully_styled4
    <span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class="py_output">Hello world!</span>
    <span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span class="py_prompt">... </span><span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>

By inspection, we conclude that it does appear to be correct.

In previous version, we noticed that there was a bug when a comment
was inserted as the last line of an interpreter session.  We need to
see if we have to take care of this in this version.

    >>> end_comment6 = '''&gt;&gt;&gt; # this is a comment'''
    >>> python_code6, extracted6 = colourize.extract_code_from_interpreter(end_comment6)
    >>> print colourize.style(python_code6)
    <span class='py_comment'># this is a comment</span>

This looks ok; let us try a slightly longer example.
    >>> end_comment7 = """&gt;&gt;&gt; print 'Hello world!'
    ... Hello world!
    ... &gt;&gt;&gt; for i in range(3):
    ... ...     print i*i
    ... &gt;&gt;&gt; # another comment."""
    >>> python_code7, extracted7 = colourize.extract_code_from_interpreter(end_comment7)
    >>> print colourize.style(python_code7)
    <span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>
    <span class='py_keyword'>for</span><span class='py_variable'> i</span><span class='py_keyword'> in</span><span class='py_builtins'> range</span><span class='py_op'>(</span><span class='py_number'>3</span><span class='py_op'>)</span><span class='py_op'>:</span>
    <span>    </span><span class='py_keyword'>print</span><span class='py_variable'> i</span><span class='py_op'>*</span><span class='py_variable'>i</span>
    <span class='py_comment'># another comment.</span>

Again, by inspection, this looks correct.

We now proceed to implement a new feature, intended to automatically detect
if a python code sample represents a simulated interpreter session.

ASSUMPTION: we will assume, as has been the case so far, that any code will
be aligned to the left i.e. that there is no extra spaces added at the
beginning of each line (unlike the doctests examples embedded in this page).
In the future, if it proves necessary, this condition could be relaxed,
at the cost of some minor increase complexity of the code written so far.

We consider the two simplest case first.
    >>> sample1 = '''print "Hello world!"'''
    >>> sample2 = '''&gt;&gt;&gt; print "Hello world!"'''
    >>> print colourize.is_interpreter_session(sample1)
    False
    >>> print colourize.is_interpreter_session(sample2)
    True

We then consider two more cases, with blank lines inserted at the beginning:
    >>> sample7 = '''\n\nprint "Hello world!"'''
    >>> sample8 = '''   \n  \n&gt;&gt;&gt; print "Hello world!"'''
    >>> print colourize.is_interpreter_session(sample7)
    False
    >>> print colourize.is_interpreter_session(sample8)
    True

We use this function inside colourize.py to proceed, reusing some
examples introduced previously.  We know, from the tests done above,
that the new version still works with non-interpreter code.  We can use
some previous examples to test the interpreter version.

    >>> print colourize.style(code_sample3) == fully_styled3
    True
    >>> print colourize.style(code_sample4) == fully_styled4
    True

In case we find a discrepancy, we compare with the expected result.
    >>> print colourize.style(code_sample3)
    <span class="py_prompt">&gt;&gt;&gt; </span><span class='py_keyword'>print</span><span class='py_string'> 'Hello world!'</span>

Using this code with sample pages, we noted that sometimes blank lines
were added either at the beginning and/or at the end of a code sample.
As this can lead to too much blank vertical spaces inserted in html pages
displayed by Crunchy, we will introduce a function which will be used to
removed such lines.

    >>> test_blank = '\n \r\n\n\r  \nline1\nline2 followed by blank line\n\nline3\n \n'
    >>> print colourize.trim_empty_lines_from_end(test_blank)
    line1
    line2 followed by blank line
    <BLANKLINE>
    line3
    >>> test_blank2 = 'line1\nline2'
    >>> print colourize.trim_empty_lines_from_end(test_blank2)
    line1
    line2


