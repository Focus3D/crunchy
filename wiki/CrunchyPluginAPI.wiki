Documentation for the Crunchy Plugin API *This does not apply to the current 0.8a release*

*Note: This is no longer in sync with the latest SVN head*

= Introduction =

Crunchy is turning into a web framework with plugins.  These plugins handle almost all of the Crunchy-specific work, so the core application could easily be adapted for other uses (although it really is pretty basic).

Some things I'm thinking of adding: 
  * A way of knowing what services a plugin provides and what services it requires without registering it.
  * Using the above to determine loading order. This would be wonderfully complicated and technical and great fun :)

Here is a diagram explaining what happens when a normal VLAM page is created:

http://mar05b.imghost.us/SYwO.png

= CrunchyPlugin =

This is the base class for all plugins.

It has the following methods:

== __init__(self) ==

*This must not be overridden by any subclasses.*

Provides general plugin initialisation. Calls the `register()` method.

== register(self) ==

*This must be overriden by all sublasses.*

Provides plugin-specific initialisation.

Example:
{{{
class MyPlugin(CrunchyPlugin):
    def register(self):
        print "registering..."
}}}

== register_http_handler(self, pattern, handler) ==

*This should not be overriden by subclasses*

Used to register a custom handler for an http path.

If `pattern` is `None` then handler will be registered as the default handler (which handles all otherwise unmatched paths). Otherwise `pattern` should be a string containing the path to match.

`handler` should be a callable object that takes one argument: A CrunchyRequest object (see below).

{{{
class MyPlugin(CrunchyPlugin):
    def register(self):
        self.register_http_handler("/mypath", self.mypath_handler)
    def mypath_handler(self, request):
        print "handling /mypage"
}}}

== register_vlam_handler(self, elem_type, option, handler) ==

*This should not be overriden by subclasses*

Used to register a custom handler for an VLAM element.

`elem_type` and `option` should be Strings. `elem_type` should match the tag of the html object and `option` should match the value of its type attribute.

`handler` should be a callable object that takes three arguments: A CrunchyPage object (see below), an elementtree.Element object and a unique string ID (uid).

Example:
{{{
class MyPlugin(CrunchyPlugin):
    def register(self):
        self.register_vlam_handler("pre", "editor", self.insert_editor)
    def insert_editor(self, page, elem, uid):
        print "inserting an editor..."
}}}

== create_vlam_page(self, filehandle) ==

*This should not be overriden by subclasses*

Creates (and returns) a CrunchyPage object from filehandle. CrunchyPage objects should not be created directly but via this factory function.

== exec_code(self, uid) ==

*This should not be overriden by subclasses*

Executes some code in a new thread. Uses `uid` as the IO redirection ID (see CrunchyCommunication).

== register_service(self, function) ==

*This must not be overriden by any subclasses*

Creates a new service. Services are functions accessible from all plugins.

`function` should be a callable object. Once registered it will be available to all plugins by calling `self.service_name()` where `service_name` is function.__name__.

*Note:* While it is currently possible to override all the methods described in this documentation, it is *NOT* recommended. In future it will probably be disallowed.

Example:
{{{
class ServiceTest(CrunchyPlugin):
    """tests the custom service functionality"""
    def register(self):
        self.register_service(ServiceTest.test_service)
        self.register_http_handler("/service_test", self.test_http)
        
    def test_http(self, rq):
        rq.send_response(200)
        rq.end_headers()
        rq.wfile.write(self.test_service({"test_key1":1}))
        
    def test_service(self, arg):
        return str(arg)
}}}

= CrunchyRequest =

This is the object passed to custom http handlers (see above).

For now this is more or less a SimpleHTTPRequestHandler object, but in future it will become more customised and deveoper friendly.

#todo: design a proper API for this

Here are some instance variables:

== path ==

A String containing the path of the http request.

== args ==

A dict containing any arguments that were encodeed in the URL.

== data ==

A string containing any data sent in the body of the request, only really relevant to POST requests.

And some useful methods:

== send_response(code) ==

Begins an HTTP response. Sends off the `code` as the HTTP response code.

== end_headers() ==

Ends the HTTP header block and readies the connection for data to be sent.

== wfile.write(data) ==

Writes data to the connection.

*Note:* This will definately change in future to just `write()` or `write_data()`.

Example:
{{{
def custom_http_handler(request):
    print request.path
    request.send_respoonse(200)
    request.end_headers()
    request.wfile.write("Hello!")
}}}

= CrunchyPage =

This is the object used to parse and store the state of a VLAM page.

It is currently not at all developer friendly or documentable (I'm still in the process of moving stuff out of here and into plugins).

#todo: get a proper API in here too.